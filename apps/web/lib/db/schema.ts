import { relations, sql } from 'drizzle-orm';

// ---------------------------------------------------------------------------
// Re-export better-auth tables (user, session, account, verification, etc.)
// Generated by: npx @better-auth/cli generate
// ---------------------------------------------------------------------------
export * from './auth-schema';
// Import user for relations
import { user } from './auth-schema';
import {
  boolean,
  check,
  index,
  integer,
  jsonb,
  pgTable,
  real,
  text,
  timestamp,
  unique,
  uuid,
} from 'drizzle-orm/pg-core';

// ---------------------------------------------------------------------------
// Reusable column helpers
// ---------------------------------------------------------------------------

const id = uuid('id').primaryKey().defaultRandom();

const timestamps = {
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true })
    .defaultNow()
    .notNull()
    .$onUpdateFn(() => new Date()),
};

const createdAt = timestamp('created_at', { withTimezone: true }).defaultNow().notNull();

// ---------------------------------------------------------------------------
// skills
// ---------------------------------------------------------------------------

export const skills = pgTable(
  'skills',
  {
    id,
    name: text('name').notNull().unique(),
    description: text('description'),
    publisherId: text('publisher_id')
      .notNull()
      .references(() => user.id),
    orgId: text('org_id'),
    repositoryUrl: text('repository_url'),
    status: text('status').notNull().default('active'),
    statusReason: text('status_reason'),
    statusChangedBy: text('status_changed_by').references(() => user.id, { onDelete: 'set null' }),
    statusChangedAt: timestamp('status_changed_at', { withTimezone: true }),
    featured: boolean('featured').notNull().default(false),
    featuredBy: text('featured_by').references(() => user.id, { onDelete: 'set null' }),
    featuredAt: timestamp('featured_at', { withTimezone: true }),
    ...timestamps,
  },
  (table) => [
    // Name format: optional @scope/ prefix, then lowercase alphanumeric + hyphens
    check(
      'skills_name_format',
      sql`${table.name} ~ '^(@[a-z0-9-]+\/)?[a-z0-9][a-z0-9-]*$'`,
    ),
    // Max 214 characters (npm convention)
    check('skills_name_length', sql`length(${table.name}) <= 214`),
    // Index for filtering by org
    index('skills_org_id_idx').on(table.orgId),
    // GIN index for full-text search
    index('skills_search_idx').using(
      'gin',
      sql`to_tsvector('english', ${table.name} || ' ' || coalesce(${table.description}, ''))`,
    ),
    // JOIN key: every read query joins publishers ON p.id = s.publisher_id
    index('skills_publisher_id_idx').on(table.publisherId),
    // Default browse ORDER BY updated_at DESC (non-search list path)
    index('skills_updated_at_idx').on(table.updatedAt),
    index('skills_status_idx').on(table.status),
    index('skills_featured_idx').on(table.featured),
  ],
);

// ---------------------------------------------------------------------------
// skill_versions
// ---------------------------------------------------------------------------

export const skillVersions = pgTable(
  'skill_versions',
  {
    id,
    skillId: uuid('skill_id')
      .notNull()
      .references(() => skills.id),
    version: text('version').notNull(),
    integrity: text('integrity').notNull(),
    tarballPath: text('tarball_path').notNull(),
    tarballSize: integer('tarball_size').notNull(),
    fileCount: integer('file_count').notNull(),
    manifest: jsonb('manifest').notNull(),
    permissions: jsonb('permissions').notNull(),
    auditScore: real('audit_score'),
    auditStatus: text('audit_status').notNull().default('pending'),
    readme: text('readme'),
    publishedBy: text('published_by')
      .notNull()
      .references(() => user.id),
    createdAt,
  },
  (table) => [
    // No duplicate versions per skill
    unique('skill_versions_skill_version_uniq').on(table.skillId, table.version),
    // Composite: covers MAX(created_at) subquery in search + ORDER BY created_at DESC in detail/versions
    index('skill_versions_skill_id_created_at_idx').on(table.skillId, table.createdAt),
  ],
);

// ---------------------------------------------------------------------------
// skill_downloads
// ---------------------------------------------------------------------------

export const skillDownloads = pgTable(
  'skill_downloads',
  {
    id,
    skillId: uuid('skill_id')
      .notNull()
      .references(() => skills.id),
    versionId: uuid('version_id')
      .notNull()
      .references(() => skillVersions.id),
    ipHash: text('ip_hash'),
    userAgent: text('user_agent'),
    createdAt,
  },
  (table) => [
    index('skill_downloads_skill_id_idx').on(table.skillId),
    index('skill_downloads_created_at_idx').on(table.createdAt),
  ],
);

// ---------------------------------------------------------------------------
// audit_events
// ---------------------------------------------------------------------------

export const auditEvents = pgTable('audit_events', {
  id,
  action: text('action').notNull(),
  actorId: text('actor_id'),
  targetType: text('target_type'),
  targetId: text('target_id'),
  metadata: jsonb('metadata'),
  createdAt,
});

// ---------------------------------------------------------------------------
// user_status
// ---------------------------------------------------------------------------

export const userStatus = pgTable(
  'user_status',
  {
    id,
    userId: text('user_id')
      .notNull()
      .references(() => user.id, { onDelete: 'cascade' }),
    status: text('status').notNull(),
    reason: text('reason'),
    bannedBy: text('banned_by').references(() => user.id, { onDelete: 'set null' }),
    expiresAt: timestamp('expires_at', { withTimezone: true }),
    ...timestamps,
  },
  (table) => [
    index('user_status_user_id_idx').on(table.userId),
    index('user_status_status_idx').on(table.status),
  ],
);

// ---------------------------------------------------------------------------
// scan_results
// ---------------------------------------------------------------------------

export const scanResults = pgTable(
  'scan_results',
  {
    id,
    versionId: uuid('version_id')
      .notNull()
      .references(() => skillVersions.id),
    verdict: text('verdict').notNull(), // 'pass', 'pass_with_notes', 'flagged', 'fail'
    totalFindings: integer('total_findings').notNull().default(0),
    criticalCount: integer('critical_count').notNull().default(0),
    highCount: integer('high_count').notNull().default(0),
    mediumCount: integer('medium_count').notNull().default(0),
    lowCount: integer('low_count').notNull().default(0),
    stagesRun: jsonb('stages_run').notNull().$type<string[]>(),
    durationMs: integer('duration_ms'),
    fileHashes: jsonb('file_hashes').$type<Record<string, string>>(),
    createdAt,
  },
  (table) => [
    // Composite: covers LATERAL (ORDER BY created_at DESC LIMIT 1) in version detail route
    index('scan_results_version_id_created_at_idx').on(table.versionId, table.createdAt),
  ],
);

// ---------------------------------------------------------------------------
// scan_findings
// ---------------------------------------------------------------------------

export const scanFindings = pgTable(
  'scan_findings',
  {
    id,
    scanId: uuid('scan_id')
      .notNull()
      .references(() => scanResults.id),
    stage: text('stage').notNull(), // 'stage0', 'stage1', ..., 'stage5'
    severity: text('severity').notNull(), // 'critical', 'high', 'medium', 'low'
    type: text('type').notNull(), // e.g. 'prompt_injection', 'shell_injection', 'secret_found'
    description: text('description').notNull(),
    location: text('location'), // e.g. 'SKILL.md:47' or 'script.py:12'
    confidence: real('confidence'), // 0.0-1.0
    tool: text('tool'), // which tool/rule found it
    evidence: text('evidence'), // raw snippet or pattern matched
    createdAt,
  },
  (table) => [
    index('scan_findings_scan_id_idx').on(table.scanId),
    index('scan_findings_severity_idx').on(table.severity),
  ],
);

// ---------------------------------------------------------------------------
// Relations
// ---------------------------------------------------------------------------

export const skillsRelations = relations(skills, ({ one, many }) => ({
  publisher: one(user, {
    fields: [skills.publisherId],
    references: [user.id],
  }),
  statusChangedByUser: one(user, {
    fields: [skills.statusChangedBy],
    references: [user.id],
  }),
  featuredByUser: one(user, {
    fields: [skills.featuredBy],
    references: [user.id],
  }),
  versions: many(skillVersions),
  downloads: many(skillDownloads),
}));

export const skillVersionsRelations = relations(skillVersions, ({ one, many }) => ({
  skill: one(skills, {
    fields: [skillVersions.skillId],
    references: [skills.id],
  }),
  publishedByUser: one(user, {
    fields: [skillVersions.publishedBy],
    references: [user.id],
  }),
  downloads: many(skillDownloads),
  scanResults: many(scanResults),
}));

export const scanResultsRelations = relations(scanResults, ({ one, many }) => ({
  version: one(skillVersions, {
    fields: [scanResults.versionId],
    references: [skillVersions.id],
  }),
  findings: many(scanFindings),
}));

export const scanFindingsRelations = relations(scanFindings, ({ one }) => ({
  scan: one(scanResults, {
    fields: [scanFindings.scanId],
    references: [scanResults.id],
  }),
}));

export const skillDownloadsRelations = relations(skillDownloads, ({ one }) => ({
  skill: one(skills, {
    fields: [skillDownloads.skillId],
    references: [skills.id],
  }),
  version: one(skillVersions, {
    fields: [skillDownloads.versionId],
    references: [skillVersions.id],
  }),
}));

export const userStatusRelations = relations(userStatus, ({ one }) => ({
  user: one(user, {
    fields: [userStatus.userId],
    references: [user.id],
  }),
  bannedByUser: one(user, {
    fields: [userStatus.bannedBy],
    references: [user.id],
  }),
}));
